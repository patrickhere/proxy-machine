# The Proxy Machine: Technical Project Overview for AI Agents

## Project Classification
**Domain:** Trading Card Game (TCG) Asset Management & Print Production
**Primary Game:** Magic: The Gathering
**Architecture:** Python CLI + Makefile + SQLite + Web Dashboard
**Scale:** 500K+ card database, 15K+ local assets, multi-user profiles

---

## Core Problem Statement

Magic: The Gathering players need high-quality proxy cards for casual play, testing, or collection completion. The official card pool exceeds 500,000 unique printings across 30+ years, with multiple art variants, languages, and special treatments. Players face challenges:

1. **Asset Discovery**: Finding specific card art across hundreds of sets
2. **Collection Management**: Organizing 10K+ images across multiple decks/profiles
3. **Print Production**: Converting card images to print-ready PDFs with precise layouts
4. **Format Compatibility**: Supporting multiple deck list formats (Moxfield, Archidekt, MTGA, etc.)
5. **Token Management**: Identifying and fetching tokens generated by deck cards
6. **Data Integrity**: Maintaining sync between Scryfall's bulk data and local database

---

## System Architecture

### Data Layer
**Scryfall Integration:**
- Bulk data sources: `all-cards.json.gz` (2.3GB, 508K+ cards), `oracle-cards.json.gz` (157MB), `unique-artwork.json.gz` (226MB)
- SQLite materialization: 764MB database with FTS5 full-text search
- Auto-rebuild on bulk data updates
- Graceful fallback to JSON when database unavailable

**Local Storage Structure:**
```
magic-the-gathering/
├── shared/                    # Centralized asset library
│   ├── basic-lands/          # 5,372 cards
│   ├── non-basic-lands/      # 7,539 cards
│   ├── tokens/               # 2,401 cards (organized by subtype/set)
│   ├── creatures/            # Fetchable on-demand
│   ├── enchantments/
│   ├── artifacts/
│   ├── instants/
│   ├── sorceries/
│   ├── planeswalkers/
│   └── card-backs/           # 13 backs
├── proxied-decks/            # Per-user profiles
│   └── {profile}/
│       ├── pictures-of-cards/
│       │   ├── to-print/     # Print queue
│       │   │   ├── front/
│       │   │   ├── back/
│       │   │   └── double_sided/
│       │   ├── shared-cards/ # Symlinks to shared/
│       │   ├── archived/
│       │   └── misc-alt-arts/
│       ├── pdfs-of-decks/
│       ├── deck-reports/
│       └── other/
└── bulk-data/                # Scryfall bulk files + database
```

### File Naming Convention
**Lands:** `{name}-{arttype}-{lang}[-{collector}].png`
**Tokens:** `{subtype}/{set}/{name}-{arttype}-{lang}-{set}.png`
**Other Cards:** `{name}-{arttype}-{lang}-{set}[-{collector}].png`

**Art Types:** standard, fullart, showcase, borderless, extended, retro, textless
**Modifiers:** oilslick, etched, glossy, gilded, serialized, ub, booster, concept, thick

### Processing Pipeline

**PDF Generation Flow:**
1. Scan `to-print/front/`, `to-print/back/`, `to-print/double_sided/`
2. Validate card counts (fronts must be multiple of 8)
3. Apply layout template (Letter/Tabloid/A4/A3, various card sizes)
4. Optional: crop borders, extend corners, adjust PPI
5. Generate PDF with proper page ordering for duplex printing
6. Support for deck subfolders (e.g., `front/commander-deck/`)

**Image Fetching Flow:**
1. Query database or JSON bulk data
2. Filter by: set, language, art type, rarity, type line, keywords
3. Download from Scryfall CDN (8 concurrent threads)
4. Validate byte counts (retry corrupted downloads)
5. Apply naming convention
6. Organize into appropriate shared/ subfolder

---

## Key Features & Capabilities

### 1. Deck Format Parsers (Plugin System)
**Supported Formats:**
- Simple list (one card per line)
- MTGA (Arena export format)
- Moxfield (with set/collector info)
- Archidekt (quantity prefix format)
- Deckstats (bracket notation)
- MTGGoldfish, TappedOut (URL parsing)
- Scryfall JSON

**Parser Testing:** 5 regression tests ensure format compatibility

### 2. Asset Fetching System
**Commands:**
- `make fetch-basics [SET=ltr] [LANG=en,ph]` - Basic lands
- `make fetch-nonbasics [SET=mh3]` - Non-basic lands
- `make fetch-tokens [SUBTYPE=Spirit] [SET=mh3]` - Tokens
- `make fetch-cards TYPE=creature RARITY=rare` - Universal card fetcher

**Features:**
- Multi-language support (15+ languages)
- Art type filtering
- Set-specific downloads
- Automatic retry on corruption
- Byte validation
- Rate limiting (Scryfall-compliant)

### 3. Advanced Token Pack Builder
**Capabilities:**
- Parses deck lists to extract card names
- Queries SQLite database for oracle text
- Regex-based token extraction from oracle text
- Quantity suggestions based on card text
- Availability checking (tokens in collection)
- Generates fetch commands

**Example Output:**
```
Token Suggestions:
  Treasure             x4   [12 available]
  Goblin               x3   [45 available]
  Spirit               x2   [not in collection]
```

### 4. Coverage Analysis
**Capabilities:**
- Per-set coverage reports (CSV/JSON)
- Missing card identification
- Art type distribution
- Language coverage
- Finder integration (macOS)
- `--missing-only` filtering

### 5. Collection Insights
**Statistics Provided:**
- Card type breakdown (9 categories)
- Top 10 sets by card count
- Art type distribution
- Language distribution
- Disk usage analysis (21GB+ typical)

### 6. Bulk Data Auditing
**Integrity Checks:**
- File size validation (prevents truncated downloads)
- JSON structure validation
- Database sync verification
- Configurable size/record ranges

### 7. Plugin Regression Suite
**Tests:**
- 5 deck format parsers
- Canonical sample decks
- Card count verification
- Set code extraction
- Quantity parsing

---

## Technical Implementation Details

### Database Schema (SQLite)
**Primary Table: `cards`**
- 32 fields including: id, name, oracle_text, type_line, mana_cost, cmc, colors, rarity, set, collector_number, lang, image_uris, etc.
- FTS5 full-text search on: name, oracle_text, type_line
- 10 composite indexes for performance
- 508K+ records

### Art Type Derivation Algorithm
**Priority Order:**
1. textless (highest priority)
2. borderless (border_color check)
3. showcase (frame_effects)
4. extended (extendedart)
5. retro (frame == '1993')
6. fullart (full_art flag)
7. standard (fallback)

**Modifiers Applied:** inverted → oilslick (ONE/MOM/MAT sets), etched, glossy, gilded, serialized, acorn, ub, booster, concept, thick

### PDF Layout System
**Supported Layouts:**
- Paper sizes: Letter, Tabloid, A4, A3, ArchB
- Card sizes: Standard, Standard Double, Japanese, Poker, Bridge, Tarot, Domino
- Configurable: crop, corner extension, PPI, quality
- Template-based positioning (layouts.json)

### Concurrent Processing
- Token downloads: ThreadPoolExecutor with 8 workers
- Image optimization: Parallel processing
- Bulk data parsing: Streaming JSON

---

## Command Surface

### Make Commands (60+)
**Setup & Maintenance:**
- `make setup` - First-time environment setup
- `make status` - Collection statistics
- `make verify` - Workspace health check
- `make backup` - Git bundle + snapshot

**Asset Management:**
- `make fetch-basics/nonbasics/tokens/cards` - Asset fetching
- `make optimize-images` - PNG optimization
- `make dedupe-images` - Duplicate removal

**Analysis & Reports:**
- `make deck-report DECK=path` - Deck analysis
- `make land-coverage TYPE=all` - Coverage reports
- `make collection-report` - Collection insights
- `make bulk-audit` - Data integrity check

**Testing & Verification:**
- `make test` - Syntax check
- `make verify-docs` - Documentation consistency
- `make test-plugins` - Parser regression tests

**PDF Generation:**
- `make pdf PROFILE=name` - Single profile
- `make pdf-batch PROFILES=a,b,c` - Multiple profiles

**Database:**
- `make bulk-index-build` - Build SQLite database
- `make bulk-sync` - Update all bulk data
- `make db-optimize` - Add indexes

### Interactive Menu
**Sections:**
- Deck Tools (PDF generation, analysis)
- Tokens (search, fetch, pack builder)
- Profiles (create, delete, initialize)
- Maintenance (health checks, coverage)
- Plugins (enable/disable parsers)

---

## Code Quality & Testing

### Documentation
- **GUIDE.md**: User quick-start (160 lines)
- **REFERENCE.md**: Complete command/API docs (460 lines)
- **WORKFLOW.md**: Engineering conventions (345 lines)
- **IDEAS.md**: Roadmap & planning (109 lines)
- **CHANGELOG.md**: Development history (305 lines)

### Verification Systems
- **verify_docs.py**: Automated doc consistency checking
  - Make command validation
  - File naming pattern verification
  - Cross-reference validation
  - Art type documentation accuracy

- **test_plugins.py**: Deck parser regression tests
  - 5 format tests
  - Sample deck fixtures
  - Card count verification

- **audit_bulk.py**: Data integrity auditing
  - File size validation
  - JSON structure checks
  - Database sync verification

### Pre-Commit Hooks
- Trailing whitespace removal
- End-of-file fixer
- YAML/JSON validation
- Ruff linting + formatting
- Black formatting
- Python compilation check
- Documentation verification

---

## Performance Characteristics

### Scale
- **Database**: 764MB SQLite, 508K+ cards
- **Bulk Data**: 2.6GB compressed JSON
- **Local Assets**: 15,312 cards, 21GB storage
- **Query Performance**: <100ms for most searches (with indexes)

### Optimization Strategies
- Concurrent downloads (8 threads)
- Database materialization (vs JSON parsing)
- FTS5 full-text search
- Composite indexes
- Streaming JSON parsing
- Byte validation (prevents re-downloads)

---

## Extension Points

### Plugin System
**Current Plugins:**
- MTG (core)
- Digimon, Flesh and Blood, Grand Archive, Gundam, Lorcana, Netrunner, One Piece, Riftbound, Yu-Gi-Oh!

**Plugin Structure:**
- `__init__.py` with PLUGIN metadata
- Deck format parsers
- Custom fetch logic
- Set-specific handling

### Customization
- Layout templates (JSON-based)
- Profile configurations
- Notification webhooks
- Discord integration
- Custom scrapers

---

## Known Limitations & Considerations

1. **macOS-Centric**: Some features use AppleScript (Finder reveal, notifications)
2. **Scryfall Dependency**: Requires Scryfall API/bulk data availability
3. **Disk Space**: Full collection can exceed 50GB
4. **Database Rebuild**: Can take 5-10 minutes for 508K+ cards
5. **Image Quality**: Dependent on Scryfall's image availability
6. **No GUI**: Command-line focused (web dashboard is minimal)

---

## Recent Development Velocity

**Session 2025-10-15 (3 hours):**
- 7 features implemented
- 5 new tools created (~900 lines)
- 6 new make commands
- Complete documentation overhaul
- All emoji removal (user preference)

**Session 2025-10-14:**
- Documentation restructure (5 files)
- Makefile cleanup (14 command changes)
- Web scraper integration
- File corruption recovery

**Session 2025-10-06:**
- 8x performance improvement (token downloads)
- Database optimization (10 indexes)
- Hobby features (artist search, random discovery)

---

## AI Agent Collaboration Opportunities

### Areas for Input

1. **Deck Validation Logic**: Suggest algorithms for pre-print validation (missing cards, duplicates, legality)

2. **Image Quality Scoring**: Propose ML-based or heuristic approaches for automated quality assessment

3. **Print Layout Optimization**: Algorithm to minimize paper waste given arbitrary card counts

4. **Token Detection Enhancement**: Improve regex patterns for oracle text parsing (current: ~80% accuracy)

5. **Database Query Optimization**: Suggest indexing strategies for common query patterns

6. **Profile Management**: Design patterns for bulk profile operations (copy, merge, sync)

7. **Set Release Automation**: Architecture for monitoring Scryfall for new releases

8. **Cost Estimation**: Model for calculating paper/ink costs per deck

9. **Caching Strategy**: Design for query result caching with invalidation

10. **Error Recovery**: Patterns for graceful degradation when database/network unavailable

### Technical Constraints

- **Language**: Python 3.11+
- **Database**: SQLite (no external DB servers)
- **Dependencies**: Minimal (requests, click, PIL, natsort, pydantic)
- **Platform**: macOS primary, but portable design preferred
- **Performance**: Sub-second response for interactive commands
- **Storage**: Assume 100GB+ available for full collection

### Code Style Preferences

- **NO EMOJIS** (strong user preference)
- Type hints throughout
- Docstrings for public functions
- Single-line progress updates (not verbose)
- Click for CLI interfaces
- Makefile for user-facing commands
- Tools in `tools/` directory
- Tests alongside features

---

## Questions for AI Agent Review

1. Are there better approaches to the token detection problem beyond regex?
2. How would you architect a print queue system with priority/scheduling?
3. What's the best way to handle incremental database updates (vs full rebuild)?
4. Suggestions for deck legality validation without external API calls?
5. How to implement efficient duplicate image detection across 15K+ files?
6. Best practices for profile template system design?
7. Recommendations for set release notification architecture?
8. Optimal caching strategy for frequently-accessed card data?
9. How to improve parser test coverage beyond current 5 formats?
10. Suggestions for making the system more platform-agnostic?

---

---

## Recent Major Enhancements (October 2025)

### 1. Universal Fetch System & Consolidation
**Problem:** Three separate fetch functions (~1000 lines) with duplicate logic and inconsistent behavior.

**Solution:**
- Created `_fetch_cards_universal()` - single function for ALL card types
- Consolidated basic_land, nonbasic_land, token fetchers into thin wrappers (15-18 lines each)
- Eliminated ~800 lines of duplicate code (62% reduction)
- Integrated all_parts relationship expansion for ALL card types (not just lands)

**Benefits:**
- Single source of truth for fetch operations
- Consistent filtering across all card types
- Easier maintenance (bug fixes in one place)
- Extensible (easy to add new card types)

### 2. SQL Query Optimization (95% Memory Reduction)
**Problem:** Loading all 508k cards (~2GB RAM) into memory, then filtering in Python.

**Solution:**
- Created `query_cards_optimized()` in `db/bulk_index.py`
- Pushes ALL filters to SQL WHERE clause
- Returns only matching cards instead of full dataset

**Performance:**
- Before: 2013.9MB memory usage
- After: 94.2MB memory usage
- Savings: 1920MB (95% reduction)

**Technical Details:**
- SQL-level filtering for: card_type, is_token, is_basic_land, lang, set, name, type_line, subtype, artist, rarity, layout, frame, border_color, fullart
- Parameterized queries prevent SQL injection
- Supports both single and multiple language filters
- Proper case-insensitive matching with LOWER()

### 3. Card Relationships Tracking
**Problem:** No way to query MDFC pairs, meld combinations, or token producers.

**Solution:**
- Added `card_relationships` table (schema v6)
- Tracks 4 relationship types:
  - combo_piece: 114,470 (MDFC, adventure, split cards)
  - token: 15,243 (tokens created by cards)
  - meld_part: 254 (cards that meld together)
  - meld_result: 110 (meld results)
- Auto-populates during bulk index build
- Indexed on source_card_id, related_card_id, relationship_type

**Query Tool:** `tools/query_relationships.py`
```bash
# Show statistics
python tools/query_relationships.py --stats

# Find meld pairs
python tools/query_relationships.py --meld-pairs

# Find MDFCs in a set
python tools/query_relationships.py --mdfcs znr

# Find cards that produce a token
python tools/query_relationships.py --token-producers "Spirit"

# Show all relationships for a card
python tools/query_relationships.py --card "Brisela"

# List sets with MDFCs
python tools/query_relationships.py --mdfc-sets
```

### 4. Database Type Safety System
**Problem:** Column name mismatches causing bugs (e.g., "set" vs "set_code", "image_uris_png" vs "image_url").

**Solution:** Created `db/types.py` module with:
- `DBColumns` class: All 33 column name constants
- `CardRelationshipColumns` class: Relationship table columns
- `RelationshipType` class: Valid relationship type constants
- `PrintRow` TypedDict: Type-safe database row structure
- `CardRelationshipRow` TypedDict: Relationship row structure
- Helper functions: `bool_to_db()`, `db_to_bool()`, `get_column()`

**Benefits:**
- IDE autocomplete for column names
- Type checking with mypy/pyright
- Prevents typos (compile-time errors)
- Centralized schema documentation
- Easier refactoring

**Example Usage:**
```python
from db.card_types import DBColumns, PrintRow

# Type-safe column access
name = entry.get(DBColumns.NAME, "Unknown")
set_code = entry.get(DBColumns.SET_CODE, "")
image_url = entry.get(DBColumns.IMAGE_URL, "")

# Type-checked row
row: PrintRow = {
    "id": "abc123",
    "name": "Lightning Bolt",
    "set_code": "lea",
    "is_token": 0,
}
```

### 5. AI-Driven Quality Improvements (October 2025 PM)
**Problem:** ChatGPT/Cascade AI review identified gaps in testing, documentation, and infrastructure.

**Solution:** Implemented all 8 recommendations systematically:

1. **Foreign Key Enforcement** - Enabled PRAGMA foreign_keys globally, prevents orphaned relationships
2. **Golden Dataset Fixtures** - Created 4 test deck files with expected values for regression testing
3. **Centralized Network Module** - Robust retry logic with exponential backoff and jitter (net/network.py)
4. **Integration Testing** - pytest framework with 14+ tests, fixture validation
5. **Developer Guide** - Comprehensive 400+ line guide for contributors (DEVELOPER_GUIDE.md)
6. **Alembic Migrations** - Schema versioning with upgrade/downgrade support
7. **Structured Logging** - Optional loguru integration with JSON logs (opt-in)
8. **Incremental Updates** - ETag-based conditional requests, bandwidth savings

**Impact:**
- 25+ files created, ~2,000 lines added
- Test coverage doubled (14 → 28+ tests)
- Documentation expanded by 50% (2,000 → 3,500+ lines)
- Production-ready error handling and retry logic
- Easy onboarding for new contributors
- Safe database schema evolution

### 6. Schema Validation Testing
**Created:** `tools/test_schema.py` - Automated schema validation

**Tests:**
- Database file exists
- prints table exists with all 33 columns
- card_relationships table exists with all 4 columns
- Recommended indexes present
- Schema version matches code (v6)
- Column types correct (TEXT, INTEGER, REAL)
- Data integrity (no NULL IDs/names, no orphaned relationships)

**Results:** 9/9 tests passing

**Run:** `make test-schema`

### 7. Enhanced CLI & Makefile
**New Commands:**
- `make fetch-cards TYPE=creature RARITY=rare SET=znr LIMIT=10` - Universal fetch
- `make test-schema` - Validate database schema
- `make query-relationships ARGS='--stats'` - Query card relationships

**Improved:**
- `--fetch_cards` now supports actual downloading (not just display)
- Dry run mode with `DRY=1` flag
- All filters pushed to SQL for performance

---

## Database Schema (v6)

### prints Table (33 columns)
**Primary Fields:**
- id, name, name_slug, set_code, collector_number, type_line

**Boolean Flags (INTEGER 0/1):**
- is_basic_land, is_token, full_art, promo, textless

**Image & Visual:**
- image_url, illustration_id, frame, frame_effects, border_color, layout

**Oracle Data:**
- oracle_id, oracle_text, keywords, color_identity, colors, produced_mana

**Card Properties:**
- artist, rarity, cmc (REAL), mana_cost, lang

**Set Information:**
- set_name, released_at

**Additional Data (JSON strings):**
- prices, legalities, all_parts

**Indexes:**
- idx_prints_name (name)
- idx_prints_oracle_id (oracle_id)
- prints_fts (FTS5 full-text search on name, oracle_text, type_line)

### card_relationships Table (4 columns)
**Schema:**
- source_card_id (TEXT, NOT NULL)
- related_card_id (TEXT, NOT NULL)
- relationship_type (TEXT, NOT NULL)
- related_card_name (TEXT)
- PRIMARY KEY (source_card_id, related_card_id, relationship_type)

**Indexes:**
- idx_relationships_source (source_card_id)
- idx_relationships_related (related_card_id)
- idx_relationships_type (relationship_type)

**Relationship Types:**
- combo_piece: MDFC faces, adventure, split cards
- meld_part: Cards that meld together
- meld_result: Result of melding
- token: Tokens created by cards

**Population:**
- Auto-populated during `make bulk-index-rebuild`
- Extracts from all_parts JSON field
- Batch inserts (1000 per batch)
- Reports statistics by type

---

## Code Architecture Patterns

### Type Safety Pattern
```python
# Instead of string literals:
entry.get("set")  # WRONG - column is "set_code"

# Use constants:
from db.card_types import DBColumns
entry.get(DBColumns.SET_CODE)  # CORRECT - type-safe
```

### Query Optimization Pattern
```python
# Old way (loads all 508k cards):
all_cards = db_query_all()
filtered = [c for c in all_cards if c['set_code'] == 'znr']

# New way (SQL-level filtering):
from db.bulk_index import query_cards_optimized
filtered = query_cards_optimized(set_filter='znr')
```

### Relationship Expansion Pattern
```python
# Find all related cards (MDFCs, tokens, meld parts):
from tools.resolve_card_relationships import expand_card_list_with_relationships

initial_ids = ["card-id-1", "card-id-2"]
expanded_ids = expand_card_list_with_relationships(
    initial_ids,
    db_path,
    include_tokens=True,
    verbose=True
)
# Returns: initial_ids + all related card IDs
```

---

## Performance Metrics

### Memory Usage
- **Full database load:** 2013.9MB
- **Optimized query (2 cards):** 94.2MB
- **Savings:** 1920MB (95% reduction)

### Query Speed
- **Full scan + Python filter:** ~3-5 seconds
- **SQL-level filter:** ~0.1-0.5 seconds
- **Speedup:** 10-50x faster

### Database Size
- **all-cards.json.gz:** 2.3GB (compressed)
- **SQLite database:** 764MB (indexed)
- **Compression ratio:** 3:1

### Asset Counts
- **Total cards in DB:** 508,405
- **Local assets:** 15,000+
- **Basic lands:** 5,372
- **Non-basic lands:** 7,539
- **Tokens:** 2,401
- **Card backs:** 13
- **Relationships tracked:** 130,077

---

## Testing Infrastructure

### Test Files
1. `tools/test_plugins.py` - Plugin regression tests (5 tests)
2. `tools/test_schema.py` - Database schema validation (9 tests)
3. `tools/verify_docs.py` - Documentation consistency checks

### Test Commands
```bash
make test              # Quick syntax check
make test-plugins      # Plugin regression tests
make test-schema       # Database schema validation
make verify-docs       # Documentation consistency
```

### CI/CD Integration
- Pre-commit hooks for documentation verification
- Automated plugin testing on code changes
- Schema validation before database operations

---

## Advanced Features

### 1. Relationship-Aware Fetching
When fetching cards, the system automatically includes related cards:
- MDFC back faces
- Meld partners and results
- Tokens created by cards
- Adventure spell faces
- Split card halves

**Example:**
```bash
make fetch-cards NAME="Valki" SET=khm
# Automatically fetches both:
# - Valki, God of Lies (front)
# - Tibalt, Cosmic Impostor (back)
```

### 2. Smart Token Detection
Analyzes oracle text to find token-producing cards:
```python
# Regex patterns for token detection:
- "create.*token"
- "put.*token.*onto the battlefield"
- "token copy"
```

### 3. Art Type Derivation
Automatically detects art variants from card data:
- fullart: full_art=true OR promo_types contains "fullart"
- showcase: frame_effects contains "showcase"
- borderless: border_color="borderless"
- extended: frame_effects contains "extendedart"
- retro: frame="1997" OR frame_effects contains "retro"

### 4. Multi-Language Support
Handles 16+ languages with proper fallback:
- Primary: en (English)
- Fantasy: ph (Phyrexian), san (Sanskrit)
- Real: es, fr, de, it, pt, ja, ko, ru, zhs, zht
- Special handling for language-specific art variants

### 5. Duplicate Detection
Multiple strategies for finding duplicate images:
- Perceptual hashing (pHash)
- Byte-level comparison
- Filename pattern matching
- Set/collector number validation

---

## Future Enhancement Ideas

### Performance
1. **Incremental database updates** - Update only changed cards instead of full rebuild
2. **Query result caching** - Cache frequent queries (e.g., "all basics in ZNR")
3. **Parallel image downloads** - Increase from 8 to 16+ workers
4. **Image compression** - Optimize PNG files without quality loss
5. **Database partitioning** - Separate tables by set or year

### Features
1. **Deck legality validation** - Check format legality without external API
2. **Print queue system** - Priority scheduling for card printing
3. **Profile templates** - Predefined configurations for common use cases
4. **Set release notifications** - Auto-fetch new sets on release
5. **Advanced search** - Boolean operators, fuzzy matching, regex support
6. **Bulk operations** - Batch rename, move, or delete cards
7. **Image quality scoring** - Rank cards by image resolution/quality
8. **Collection tracking** - Mark owned cards, track completion percentage

### Analytics
1. **Relationship visualization** - Graph view of card relationships
2. **Set completion reports** - Track collection progress by set
3. **Rarity distribution** - Analyze collection by rarity
4. **Artist statistics** - Most collected artists, art variants
5. **Language coverage** - Track multilingual card availability

### Integration
1. **Moxfield API** - Direct deck import from Moxfield
2. **Archidekt API** - Direct deck import from Archidekt
3. **EDHREC integration** - Fetch popular cards for commanders
4. **Scryfall search** - Use Scryfall's advanced search syntax
5. **Discord bot** - Card lookup and collection queries

### User Experience
1. **Web dashboard** - Browser-based interface for card management
2. **Mobile app** - iOS/Android app for on-the-go access
3. **Batch PDF generation** - Generate PDFs for multiple profiles at once
4. **Print preview** - Visual preview before PDF generation
5. **Undo/redo system** - Revert accidental changes

---

## Questions for AI Agent Review

### Architecture
1. Should we implement a proper ORM (SQLAlchemy) or keep raw SQL?
2. Is the current plugin system extensible enough for 20+ formats?
3. How to handle database migrations without breaking existing installations?
4. Best practices for managing 500k+ row database performance?

### Performance
1. Would Redis caching improve query performance significantly?
2. Should we implement connection pooling for SQLite?
3. Is there a better approach than perceptual hashing for duplicate detection?
4. How to optimize bulk image downloads beyond threading?

### Features
1. Best way to implement incremental database updates?
2. How to architect a print queue with priority/scheduling?
3. Suggestions for deck legality validation without external APIs?
4. Optimal caching strategy for frequently-accessed card data?

### Testing
1. How to improve test coverage beyond current 14 tests?
2. Best practices for testing database migrations?
3. Should we add integration tests for Scryfall API?
4. How to test PDF generation without visual inspection?

### Code Quality
1. Are there better approaches to token detection beyond regex?
2. How to make the system more platform-agnostic (Windows support)?
3. Suggestions for improving error handling and logging?
4. Best practices for managing configuration across 6+ profiles?

---

**Project Status:** Active development, production-ready for personal use, 15K+ assets managed, 6 active user profiles

**Last Updated:** 2025-10-16 (PM - AI Recommendations Complete)
**Total Codebase:** ~12.5K lines Python, 720 lines Makefile, 3,500+ lines documentation
**Database:** 508,405 cards, 130,077 relationships tracked
**Test Coverage:** 28+ automated tests (integration, plugins, schema, documentation)
**Recent Improvements:** Foreign key enforcement, schema migrations, structured logging, incremental updates, comprehensive testing
